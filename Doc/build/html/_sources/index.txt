.. Underscore for Python documentation master file, created by
   sphinx-quickstart on Fri May  6 17:46:54 2016.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Introduction
============

This is a Python adaptation of the `Underscore.js <http://underscorejs.org/>`_  JavaScript library. Most of the method definitions have been taken over, following, whenever possible, the same definition, order or arguments, etc. Some changes to the Python style and environment was nevertheless necessary, and some of the functions, closely related to JavaScript and Web Application development (e.g., function related to DOM nodes or HTML escaping), have been skipped.

A typical approach for using the library can be::

    from underscore import underscore as _

meaning that the usage syntax becomes::

    _.map([1, 2, 3], lambda num, *args: num * 3)

This is the idiom used throughout this document.

Chaining
--------

Underscore methods usually return a suitable value to be included in another method’s input. Ie, it is possible to combine two methods as follows::

    _.map(_.filter([1,2,3,200],lambda num,*args: num % 2 == 0),lambda x,*args: x*x)

I.e., the output of the ``filter`` method is used as an argument in ``map``. This may become fairly unreadable if several steps are involved, though (and having several steps is typical to the functional programming style that underscore is meant for). An alternative is to use *chaining*::

    _.chain([1,2,3,200]).filter(lambda num,*args: num % 2 == 0).map(lambda x,*args: x*x).value()

The ``chain`` method returns a wrapper object around the argument. Calling underscore methods, without the first argument, on this object means invoking the full-blown method with the wrapped object value as a first argument. Each call returns the wrapper with the newly computed value, until the ``value`` method is called. In usage terms, this means that each underscore method is invoked with the value generated by the previous element of the chain as the first argument of the method.

In fact, the call on ``chain`` is not really necessary. Creating an underscore *instance* is sufficient; ``chain`` is just a functional equivalent. I.e., the following is equivalent to the previous example::

    _([1,2,3,200]).filter(lambda num,*args: num % 2 == 0).map(lambda x,*args: x*x).value()

(Python’s indentation-based syntax makes it a bit less appealing to break the chains over several lines in the source than in javascript, because the ``\`` character must be used at the end of the line. Oh well…)

Method definitions
------------------

All (static) method below can be used directly or as methods used on a chain without the first argument (which is fed via the previous step in the chain). When looking for a specific method, see the :ref:`genindex` to find the methods, or simply search in this page.

Many methods have an **iteratee** (or **predicate**) and **context** arguments (with the latter defaulting to ``None``). In general, an **iteratee** is a (global) function, or a static method of a class, in which case a reference to that function is used as an **iteratee** without a need of a **context** argument. However, if the **iteratee** is a method for a *class instance*, then that instance has to be made available for the callback, too. That is the role of the **context**: it is the reference to the class instance, i.e., its value will be used as ``self`` in the method invocation.

Some methods have *aliases*. This simply means that the same function has two different method names with completely identical behavior. The reason for having those is because different communities have traditionally different function names for the same functionalities (e.g., “each” and “forEach”). In those cases the method description lists the aliases.

Detailed method descriptions
============================

.. automodule:: underscore
   :members:
   :undoc-members:
