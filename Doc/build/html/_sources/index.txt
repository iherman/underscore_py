.. Underscore for Python documentation master file, created by
   sphinx-quickstart on Fri May  6 17:46:54 2016.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Introduction
============

This is a Python adaptation of the `Underscore.js <http://underscorejs.org/>`_  JavaScript library. Most of the method definitions have been taken over, following, whenever possible, the same definition, order or arguments, etc. Some changes to the Python style and environment was nevertheless necessary, and some of the functions, closely related to JavaScript and Web Application development (e.g., function related to DOM nodes or HTML escaping), have been omitted.

A typical approach for using the library can be::

    from underscore import underscore as _

meaning that the usage syntax becomes::

    _.map([1, 2, 3], lambda num, *args: num * 3)

This is the idiom used throughout this document.

Chaining
--------

Underscore methods usually return a suitable value to be included in another method’s input. This means t is possible to combine two methods as follows::

    _.map(_.filter([1,2,3,200], lambda num, *args: num % 2 == 0), lambda x, *args: x*x)

I.e., the output of the ``filter`` method is used as an argument in ``map``. This may become fairly unreadable if several steps are involved (though having several steps combined is typical to the functional programming style that underscore is meant for). An alternative is to use *chaining*::

    _.chain([1,2,3,200]).filter(lambda num, *args: num % 2 == 0).map(lambda x, *args: x*x).value()

The ``chain`` method returns a wrapper object around the argument. Calling underscore methods, without the first argument, on this object means invoking the full-blown method with the wrapped object value as a first argument. Each call returns the wrapper with the newly computed value, until the ``value`` method is called: that would return the final output, i.e., the “value” of the chain. In usage terms, this means that each underscore method is invoked with the value generated by the previous element of the chain as the first argument of the method.

In fact, the call on ``chain`` is not really necessary. Creating an underscore *instance* is sufficient; ``chain`` is just a functional equivalent. I.e., the following is equivalent to the previous example::

    _([1,2,3,200]).filter(lambda num, *args: num % 2 == 0).map(lambda x, *args: x*x).value()

although using the ``chain`` method may make the code more readable for humans. (Python’s indentation-based syntax makes it a bit less appealing to break the chains over several lines in the source than in javascript, because the ``\`` character must be used at the end of the line. Oh well…)

Methods and contexts
--------------------

All (static) method below can be used directly or as methods used on a chain without the first argument (which is fed via the previous step in the chain). When looking for a specific method, see the :ref:`genindex` to find the methods, or simply search in this page.

Many methods have an **iteratee** (or **predicate**) and **context** arguments (with the latter defaulting to ``None``). In general, an **iteratee** is a (global) function, or a static method of a class, in which case a reference to that function is used as an **iteratee** without a need of a **context** argument. The same holds for a method of a class instance, if the reference to the method uses the class instance. However, in some cases, it may be useful to refer to the method using the *Class* instead of the instance, in which case the **context** argument may be used to specify the instance. Consider, for example, the following code::

    class Multiplier:
	    def __init__(self):
		    self.factor = 1
	    def setValue(self,i):
		    self.factor = i
	    def mult(self, x, *args):
		    return self.factor * x
	m = Multiplier()
	m.setValue(10)

The following two calls are then equivalent::

	_.map([2,3,4], m.mult)

and::

	_.map([2,3,4], Multiplier.mult, m)

Method Aliases
--------------

Some methods have *aliases*. This simply means that the same function has two different method names with completely identical behavior. The reason for having those is because different communities have traditionally different function names for the same functionalities (e.g., “each” and “forEach”). In those cases the method description lists the aliases.

Python versions
---------------

The module can be used with Python 2.7 or with Python 3. It cannot be used with Python 2.6 (or older versions), though.

Metadata
--------

* Version: |version|
* Document creation date: |today|
* Author: Ivan Herman
* Contact: ivan@w3.org
* Repository: <https://github.com/iherman/underscore_py>

Copyright © [2017] World Wide Web Consortium, (Massachusetts Institute of Technology, European Research Consortium for
Informatics and Mathematics, Keio University, Beihang). All Rights Reserved. This work is distributed under the
`W3C® Software License <http://www.w3.org/Consortium/Legal/copyright-software>`__ in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


Detailed method descriptions
============================

.. automodule:: underscore
   :members:
   :undoc-members:
