<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>underscore &mdash; Underscore for Python</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/my.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Underscore for Python" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Underscore for Python</span></a></h1>
        <h2 class="heading"><span>underscore</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for underscore</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># coding=utf-8</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># Tricks to handle Python3</span>
<span class="n">PY3</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
    <span class="nb">basestring</span> <span class="o">=</span> <span class="nb">str</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="c1"># noinspection PyCallByClass,PyShadowingBuiltins,PyPep8,PyPep8,PyPep8</span>
<div class="viewcode-block" id="underscore"><a class="viewcode-back" href="../index.html#underscore.underscore">[docs]</a><span class="k">class</span> <span class="nc">underscore</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods usually have a usage example to make the description clearer. Conceptually, the following Python code precedes all examples::</span>

<span class="sd">        from underscore import underscore as _</span>
<span class="sd">        listOfPlays = [</span>
<span class="sd">            {</span>
<span class="sd">                &quot;author&quot; : &quot;Shakespeare&quot;,</span>
<span class="sd">                &quot;year&quot;   : 1611,</span>
<span class="sd">                &quot;title&quot;  : &quot;The tempest&quot;</span>
<span class="sd">            },</span>
<span class="sd">            {</span>
<span class="sd">                &quot;author&quot; : &quot;Shakespeare&quot;,</span>
<span class="sd">                &quot;year&quot;   : 1611,</span>
<span class="sd">                &quot;title&quot;  : &quot;Cymbeline&quot;</span>
<span class="sd">            },</span>
<span class="sd">            {</span>
<span class="sd">                &quot;author&quot; : &quot;Shakespeare&quot;,</span>
<span class="sd">                &quot;year&quot;   : 1601,</span>
<span class="sd">                &quot;title&quot;  : &quot;Romeo and Juliet&quot;</span>
<span class="sd">            },</span>
<span class="sd">        ]</span>

<span class="sd">        stooges  = [</span>
<span class="sd">            {&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40},</span>
<span class="sd">            {&#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50},</span>
<span class="sd">            {&#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60},</span>
<span class="sd">            {&#39;name&#39;:&#39;joe&#39;, &#39;age&#39;:60}</span>
<span class="sd">        ]</span>
<span class="sd">        stooges0 = [</span>
<span class="sd">            {&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40},</span>
<span class="sd">            {&#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50},</span>
<span class="sd">            {&#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60}</span>
<span class="sd">        ]</span>
<span class="sd">        stooges2 = [</span>
<span class="sd">            {&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40},</span>
<span class="sd">            {&#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60}</span>
<span class="sd">        ]</span>

<span class="sd">        def createApplication():</span>
<span class="sd">            print(&quot;created&quot;)</span>

<span class="sd">        def isPrime(i):</span>
<span class="sd">            # code to test whether `i` is prime, returning a Boolean value</span>
<span class="sd">            ...</span>

<span class="sd">        class Multiplier:</span>
<span class="sd">            def __init__(self):</span>
<span class="sd">                self.factor = 1</span>
<span class="sd">            def setValue(self,i):</span>
<span class="sd">                self.factor = i</span>
<span class="sd">            def mult(self, x, *args):</span>
<span class="sd">                return self.factor * x</span>


<span class="sd">    These structures are used in some of the examples and are listed here to avoid repeating their definition separately.</span>

<span class="sd">    A further simplification of the examples is the usage of the ``*args`` idioms. Many “iteratee” arguments represent a function with 3-4 arguments, (look at the definition of the underscore methods), but the example uses only the first few. Instead of::</span>

<span class="sd">        lambda name, index, list: ...</span>

<span class="sd">    the abbreviation::</span>

<span class="sd">        lambda name, *args: ...</span>

<span class="sd">    is sometimes used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_exec1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">a1</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">context</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_exec2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_exec3</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">)</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_exec4</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a4</span><span class="p">)</span>

	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_extends</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ext</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ext</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
					<span class="k">return</span> <span class="bp">False</span>
			<span class="k">return</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="bp">False</span>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.each"><a class="viewcode-back" href="../index.html#underscore.underscore.each">[docs]</a>	<span class="k">def</span> <span class="nf">each</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`each`, :py:meth:`forEach`</span>

<span class="sd">        Iterates over a **lst** of elements, yielding each in turn to an **iteratee** function.</span>
<span class="sd">        Each invocation of **iteratee** is called with three arguments: if **lst** is of list type,</span>
<span class="sd">        then the arguments are ``(element, index, list)``; if it is of dictionary type</span>
<span class="sd">        the arguments are ``(value, key, list``). Returns **lst** for possible chaining.</span>

<span class="sd">        The method also works for an arbitrary iterator; however, in that case the **iteratee** is invoked</span>
<span class="sd">        with ``None`` for the second and third</span>
<span class="sd">        argument. In that case the return value of the method is also ``None``; i.e., no chaining is possible.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.each([1, 2, 3], pr)</span>
<span class="sd">            1</span>
<span class="sd">            2</span>
<span class="sd">            3</span>
<span class="sd">            &gt;&gt;&gt; _.each({&#39;one&#39;: 11, &#39;two&#39;: 22, &#39;three&#39;: 33}, pr)</span>
<span class="sd">            33</span>
<span class="sd">            22</span>
<span class="sd">            11</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">lst</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
				<span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lst</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">lst</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
			<span class="k">return</span> <span class="bp">None</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.map"><a class="viewcode-back" href="../index.html#underscore.underscore.map">[docs]</a>	<span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`map`, :py:meth:`collect`</span>

<span class="sd">        Produces a *new* array of values by mapping each value in **lst** through a transformation</span>
<span class="sd">        function (**iteratee**). Similarly to :py:meth:`each`, the **iteratee** is passed three arguments:</span>
<span class="sd">        the ``value``, then the ``index`` (or ``key``) of the iteration, and finally a reference to the entire list.</span>

<span class="sd">        The method also works for an arbitrary iterator; however, in that case the **iteratee** is invoked</span>
<span class="sd">        with ``None`` for the second and third argument.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.map([1, 2, 3], lambda num, index, list: num * 3)</span>
<span class="sd">            [3, 6, 9]</span>
<span class="sd">            &gt;&gt;&gt; _.map({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}, lambda val, key, *args: val * 4)</span>
<span class="sd">            [12, 8, 4]</span>
<span class="sd">            &gt;&gt;&gt; _.map([[1, 2], [3, 4]], lambda a, *args: _.first(a))</span>
<span class="sd">            [1, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">lst</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">))]</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">lst</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.reduce"><a class="viewcode-back" href="../index.html#underscore.underscore.reduce">[docs]</a>	<span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">memo</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`reduce`, :py:meth:`inject`</span>

<span class="sd">        Reduce boils down a **lst** of values into a single value that is returned. **memo** is the initial state</span>
<span class="sd">        of the reduction, and each successive step of it should be returned by **iteratee**. The **iteratee** is</span>
<span class="sd">        passed four arguments: ``memo`` (ie, the current state of reduction), then the ``value`` and ``index``</span>
<span class="sd">        (or ``key``) of the iteration, and finally a reference to the entire list.</span>

<span class="sd">        If no memo is passed to the initial invocation of reduce, **iteratee** is not invoked on the first element</span>
<span class="sd">        of the list. The first element is instead passed as the ``memo`` in the invocation of the **iteratee** on</span>
<span class="sd">        the next element in the list. In the case of a dictionary this means the first element of the keys, which is n</span>
<span class="sd">        ot deterministic (unless an ordered dictionary is used)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.reduce([1, 2, 3], lambda memo, num, *args: memo + num, 1)</span>
<span class="sd">            7</span>
<span class="sd">            &gt;&gt;&gt; _.reduce([1, 2, 3], lambda memo, num, *args: memo + num)</span>
<span class="sd">            6</span>
<span class="sd">            &gt;&gt;&gt; _.reduce({&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3,&#39;four&#39;:4},lambda memo, value, *args: memo*value, 2)</span>
<span class="sd">            48</span>
<span class="sd">            &gt;&gt;&gt; _.reduce({&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3,&#39;four&#39;:4},lambda memo, value, *args: memo*value)</span>
<span class="sd">            24</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;empty list with no initial value&quot;</span><span class="p">)</span>
				<span class="k">else</span> <span class="p">:</span>
					<span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec4</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">lst</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)),</span> <span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec4</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">lst</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)),</span> <span class="n">memo</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;empty dict with no initial value&quot;</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lst</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">PY3</span> <span class="k">else</span> <span class="n">lst</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
					<span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">key</span> <span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec4</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">lst</span><span class="p">),</span> <span class="n">keys</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">lst</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec4</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lst</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">lst</span><span class="p">),</span> <span class="nb">iter</span><span class="p">(</span><span class="n">lst</span><span class="p">),</span> <span class="n">memo</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;should be a list or a dict&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.find"><a class="viewcode-back" href="../index.html#underscore.underscore.find">[docs]</a>	<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`find`, :py:meth:`detect`</span>

<span class="sd">        Looks through each value in the **lst**, returning the first one that passes a truth test (**predicate**),</span>
<span class="sd">        or ``None`` if no value passes the test. The function returns as soon as it finds an acceptable</span>
<span class="sd">        element, and doesn&#39;t traverse the entire list.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.find([1, 2, 3, 4, 5, 6], lambda num: num % 2 == 0)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
					<span class="k">return</span> <span class="n">x</span>
			<span class="k">return</span> <span class="bp">None</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.filter"><a class="viewcode-back" href="../index.html#underscore.underscore.filter">[docs]</a>	<span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`filter`, :py:meth:`select`</span>

<span class="sd">        Looks through each value in the **lst**, returning an array of all the values that pass a</span>
<span class="sd">        truth test (**predicate**).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.filter([1, 2, 3, 4, 5, 6], lambda num, *args: num % 2 == 0)</span>
<span class="sd">            [2, 4, 6]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.where"><a class="viewcode-back" href="../index.html#underscore.underscore.where">[docs]</a>	<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks through each value in the **lst**, returning an array of all the values that contain all of</span>
<span class="sd">        the key-value pairs listed in **properties**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.where(listOfPlays, {&#39;author&#39;: &quot;Shakespeare&quot;, &#39;year&#39;: 1611})</span>
<span class="sd">            [{&#39;title&#39;: &#39;The tempest&#39;, &#39;year&#39;: 1611, &#39;author&#39;: &#39;Shakespeare&#39;},</span>
<span class="sd">             {&#39;title&#39;: &#39;Cymbeline&#39;, &#39;year&#39;: 1611, &#39;author&#39;: &#39;Shakespeare&#39;}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_extends</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">properties</span><span class="p">)]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.findWhere"><a class="viewcode-back" href="../index.html#underscore.underscore.findWhere">[docs]</a>	<span class="k">def</span> <span class="nf">findWhere</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks through the **lst** and returns the *first* value that matches all of the key-value pairs</span>
<span class="sd">        listed in **properties**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.findWhere(listOfPlays, {&#39;author&#39;: &quot;Shakespeare&quot;, &#39;year&#39;: 1611})</span>
<span class="sd">            {&#39;title&#39;: &#39;The tempest&#39;, &#39;year&#39;: 1611, &#39;author&#39;: &#39;Shakespeare&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_extends</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
					<span class="k">return</span> <span class="n">x</span>
			<span class="k">return</span> <span class="bp">None</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.reject"><a class="viewcode-back" href="../index.html#underscore.underscore.reject">[docs]</a>	<span class="k">def</span> <span class="nf">reject</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the values in **lst** without the elements that the truth test (**predicate**) passes. The opposite of :py:meth:`filter`.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.reject([1, 2, 3, 4, 5, 6], lambda num: num % 2 == 0)</span>
<span class="sd">            [1, 3, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.every"><a class="viewcode-back" href="../index.html#underscore.underscore.every">[docs]</a>	<span class="k">def</span> <span class="nf">every</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">predicate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if all of the values in the **lst** pass the **predicate** truth test. The default predicate is the identity.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.every([True, 1, None, &#39;yes&#39;], _.identity)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
					<span class="k">return</span> <span class="bp">False</span>
			<span class="k">return</span> <span class="bp">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.some"><a class="viewcode-back" href="../index.html#underscore.underscore.some">[docs]</a>	<span class="k">def</span> <span class="nf">some</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">predicate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`some`, :py:meth:`any`</span>

<span class="sd">        Returns ``True`` if any of the values in the **lst** pass the predicate truth test.</span>
<span class="sd">        Short-circuits and stops traversing the list if a true element is found.</span>
<span class="sd">        The default predicate is the identity.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.some([None, 0, True, False])</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
					<span class="k">return</span> <span class="bp">True</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.contains"><a class="viewcode-back" href="../index.html#underscore.underscore.contains">[docs]</a>	<span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`contains`, :py:meth:`include`</span>

<span class="sd">        Returns ``True`` if the value is present in the list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lst</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.pluck"><a class="viewcode-back" href="../index.html#underscore.underscore.pluck">[docs]</a>	<span class="k">def</span> <span class="nf">pluck</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">propertyName</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A convenient version of what is perhaps the most common use-case for :py:meth:`map`:</span>
<span class="sd">        extracting a list of property values from an array of dictionaries.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.pluck(stooges, &#39;name&#39;)</span>
<span class="sd">            [&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="n">propertyName</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.max"><a class="viewcode-back" href="../index.html#underscore.underscore.max">[docs]</a>	<span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum value in **lst**. If an **iteratee** function is provided,</span>
<span class="sd">        it will be used on each value to generate the criterion by which the value is ranked.</span>
<span class="sd">        ``float(&quot;inf&quot;)`` is returned if list is empty.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.max([1,2,3,4])&quot;</span>
<span class="sd">            4</span>
<span class="sd">            &gt;&gt;&gt; _.max([1,2,3,4], lambda x: -x)</span>
<span class="sd">            1</span>
<span class="sd">            &gt;&gt;&gt; _.max([])</span>
<span class="sd">            inf</span>
<span class="sd">            &gt;&gt;&gt; .max(stooges0, lambda stooge: stooge[&#39;age&#39;])</span>
<span class="sd">            {&#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60}</span>
<span class="sd">         &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">lst</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.min"><a class="viewcode-back" href="../index.html#underscore.underscore.min">[docs]</a>	<span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the min value in **lst**. If an **iteratee** function is provided,</span>
<span class="sd">        it will be used on each value to generate the criterion by which the value</span>
<span class="sd">        is ranked. ``float(&quot;-inf&quot;)`` is returned if list is empty, so an guard may be required.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.min([1,2,3,4])&quot;</span>
<span class="sd">            1</span>
<span class="sd">            &gt;&gt;&gt; _.min([1,2,3,4], lambda x: -x)</span>
<span class="sd">            4</span>
<span class="sd">            &gt;&gt;&gt; _.min([])</span>
<span class="sd">            -inf</span>
<span class="sd">            &gt;&gt;&gt; .min(stooges0, lambda stooge: stooge[&#39;age&#39;])</span>
<span class="sd">            {&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">lst</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.sortBy"><a class="viewcode-back" href="../index.html#underscore.underscore.sortBy">[docs]</a>	<span class="k">def</span> <span class="nf">sortBy</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sorted copy of **lst**, ranked in ascending order by the results of running each</span>
<span class="sd">        value through **iteratee**. **iteratee** may also be the string name of the property.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.sortBy([1, 2, 3, 4, 5, 6], lambda num: math.sin(num))</span>
<span class="sd">            [5, 4, 6, 3, 1, 2]</span>
<span class="sd">            &gt;&gt;&gt; _.sortBy(stooges0, &#39;name&#39;)</span>
<span class="sd">            [{&#39;age&#39;: 60, &#39;name&#39;: &#39;curly&#39;}, {&#39;age&#39;: 50, &#39;name&#39;: &#39;larry&#39;}, {&#39;age&#39;: 40, &#39;name&#39;: &#39;moe&#39;}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">iteratee</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
</div>
	<span class="nd">@staticmethod</span>
	<span class="k">def</span> <span class="nf">_group</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">iteratee</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

		<span class="n">retval</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
			<span class="n">key</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">:</span>
				<span class="n">retval</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">retval</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">retval</span>


	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.groupBy"><a class="viewcode-back" href="../index.html#underscore.underscore.groupBy">[docs]</a>	<span class="k">def</span> <span class="nf">groupBy</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a **lst** into sets, grouped by the result of running each value through **iteratee**.</span>
<span class="sd">        If **iteratee** is a string instead of a function, groups by the property named by</span>
<span class="sd">        iteratee on each of the values.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.groupBy([1.3, 2.1, 2.4], lambda num: math.floor(num))</span>
<span class="sd">            {1.0: [1.3], 2.0: [2.1, 2.4]}</span>
<span class="sd">            &gt;&gt;&gt; st2 = [{&#39;name&#39;: &#39;joe&#39;, &#39;age&#39;: 40}, {&#39;name&#39;: &#39;tom&#39;, &#39;age&#39;: 50}, {&#39;name&#39;: &#39;bill&#39;, &#39;age&#39;: 50}]</span>
<span class="sd">            &gt;&gt;&gt; _.groupBy(st2, &#39;age&#39;)</span>
<span class="sd">            {40: [{&#39;age&#39;: 40, &#39;name&#39;: &#39;joe&#39;}], 50: [{&#39;age&#39;: 50, &#39;name&#39;: &#39;tom&#39;}, {&#39;age&#39;: 50, &#39;name&#39;: &#39;bill&#39;}]}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_group</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lst must be iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.indexBy"><a class="viewcode-back" href="../index.html#underscore.underscore.indexBy">[docs]</a>	<span class="k">def</span> <span class="nf">indexBy</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a **lst**, and an **iteratee** function that returns a key for each element in the</span>
<span class="sd">        list (or a property name), returns an object with an index of each item. Just</span>
<span class="sd">        like :py:meth:`groupBy`, but when you know your keys are unique.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.indexBy(stooges0, &#39;age&#39;)</span>
<span class="sd">            {40: {&#39;age&#39;: 40, &#39;name&#39;: &#39;moe&#39;}, 50: {&#39;age&#39;: 50, &#39;name&#39;: &#39;larry&#39;}, 60: {&#39;age&#39;: 60, &#39;name&#39;: &#39;curly&#39;}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="n">grouped</span> <span class="o">=</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_group</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">g</span><span class="p">:</span><span class="n">grouped</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>  <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lst must be iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.countBy"><a class="viewcode-back" href="../index.html#underscore.underscore.countBy">[docs]</a>	<span class="k">def</span> <span class="nf">countBy</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts a **lst** into groups and returns a count for the number of objects in each group.</span>
<span class="sd">        Similar to :py:meth:`groupBy`, but instead of returning a list of values, returns a count for the</span>
<span class="sd">        number of values in that group.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.countBy([1, 2, 3, 4, 5], lambda num: &#39;even&#39; if num % 2 == 0 else &#39;odd&#39;)</span>
<span class="sd">            {&#39;even&#39;: 2, &#39;odd&#39;: 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="n">grouped</span> <span class="o">=</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_group</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">g</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">[</span><span class="n">g</span><span class="p">])</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;lst must be iterable&quot;</span><span class="p">)</span>

</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.shuffle"><a class="viewcode-back" href="../index.html#underscore.underscore.shuffle">[docs]</a>	<span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a (randomly) shuffled copy of the **lst**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.shuffle([1, 2, 3, 4, 5, 6])</span>
<span class="sd">            [6, 4, 5, 2, 1, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="n">indeces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)))</span>
		<span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">indeces</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indeces</span><span class="p">]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.sample"><a class="viewcode-back" href="../index.html#underscore.underscore.sample">[docs]</a>	<span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce a random sample from the **lst**. Pass a number to return **n** random elements from the list. Otherwise a single random item will be returned.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.sample([1, 2, 3, 4, 5, 6])</span>
<span class="sd">            1</span>
<span class="sd">            &gt;&gt;&gt; _.sample([1, 2, 3, 4, 5, 6], 3)</span>
<span class="sd">            [4, 1, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.toArray"><a class="viewcode-back" href="../index.html#underscore.underscore.toArray">[docs]</a>	<span class="k">def</span> <span class="nf">toArray</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a real array from the **lst** (anything that can be iterated over).</span>
<span class="sd">		Useful for transmuting the arguments object. An alias to the built-in **list** function.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.toArray(range(0,4))</span>
<span class="sd">            [0, 1, 2, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.size"><a class="viewcode-back" href="../index.html#underscore.underscore.size">[docs]</a>	<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of values in the **lst**. An alias to the built-in *len* function.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.size({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">            3</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.partition"><a class="viewcode-back" href="../index.html#underscore.underscore.partition">[docs]</a>	<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split **lst** into two arrays: one with elements that satisfy predicate and one with elements that do not satisfy **predicate**. If **lst** is actually a tuple, then a tuple is returned, otherwise an array, each containing the two generated arrays in the &#39;yes&#39; and &#39;no&#39; order.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.partition([0, 1, 2, 3, 4, 5], lambda num: num % 2 != 0)</span>
<span class="sd">            [[1, 3, 5], [0, 2, 4]]</span>
<span class="sd">            &gt;&gt;&gt; _.partition((0, 1, 2, 3, 4, 5), lambda num: num % 2 != 0)</span>
<span class="sd">            ((1, 3, 5), (0, 2, 4))</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="n">yes</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">no</span>  <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
					<span class="n">yes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">yes</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">no</span><span class="p">))</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="k">else</span> <span class="p">[</span><span class="n">yes</span><span class="p">,</span> <span class="n">no</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be Iterable&quot;</span><span class="p">)</span>


	<span class="c1">###############################################################################</span>
	<span class="c1">#                                Array Functions                              #</span>
	<span class="c1">###############################################################################</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.first"><a class="viewcode-back" href="../index.html#underscore.underscore.first">[docs]</a>	<span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the first element of an **array**. Passing **n** will return the first n elements of the array.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.first([5, 4, 3, 2, 1])</span>
<span class="sd">            5</span>
<span class="sd">            &gt;&gt;&gt; _.first([5, 4, 3, 2, 1],3)</span>
<span class="sd">            [5, 4, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.initial"><a class="viewcode-back" href="../index.html#underscore.underscore.initial">[docs]</a>	<span class="k">def</span> <span class="nf">initial</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns everything but the last entry of the **array**. Especially useful on the arguments object.</span>
<span class="sd">		Pass **n** to exclude the last n elements from the result.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.initial([5, 4, 3, 2, 1])</span>
<span class="sd">            [5, 4, 3, 2]</span>
<span class="sd">            &gt;&gt;&gt; _.initial([5, 4, 3, 2, 1],3)</span>
<span class="sd">            [5, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">array</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.last"><a class="viewcode-back" href="../index.html#underscore.underscore.last">[docs]</a>	<span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the last element of **array**. Passing **n** will return the last n elements of the array.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.last([5, 4, 3, 2, 1])</span>
<span class="sd">            1</span>
<span class="sd">            &gt;&gt;&gt; _.last([5, 4, 3, 2, 1],3)</span>
<span class="sd">            [3, 2, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.rest"><a class="viewcode-back" href="../index.html#underscore.underscore.rest">[docs]</a>	<span class="k">def</span> <span class="nf">rest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the rest of the elements in an **array**. Pass an index to return</span>
<span class="sd">		the values of the array from that index onward.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.rest([5, 4, 3, 2, 1])</span>
<span class="sd">            [4, 3, 2, 1]</span>
<span class="sd">            &gt;&gt;&gt; _.rest([5, 4, 3, 2, 1],3)</span>
<span class="sd">            [2, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>

	<span class="c1"># noinspection PyShadowingNames</span></div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.compact"><a class="viewcode-back" href="../index.html#underscore.underscore.compact">[docs]</a>	<span class="k">def</span> <span class="nf">compact</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the **array** with all falsy values removed. ``False``, ``None``, 0, &quot;&quot; (empty string), and ``NaN`` for floats are all falsy.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.compact([0, 1, False, 2, &#39;&#39;, 3, None, 4, float(&#39;nan&#39;), 5])</span>
<span class="sd">            [1, 2, 3, 4, 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">falsy</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span> <span class="k">if</span> <span class="n">falsy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">True</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.flatten"><a class="viewcode-back" href="../index.html#underscore.underscore.flatten">[docs]</a>	<span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shallow</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Flattens a nested **array** (the nesting can be to any depth). If you pass **shallow** with value ``True``, the array is only be flattened a single level.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.flatten([1, [2], [3, [[4]]]])</span>
<span class="sd">            [1, 2, 3, 4]</span>
<span class="sd">            &gt;&gt;&gt; _.flatten([1, [2], [3, [[4]]]], True)</span>
<span class="sd">            [1, 2, 3, [[4]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
					<span class="n">retval</span> <span class="o">+=</span>  <span class="n">x</span> <span class="k">if</span> <span class="n">shallow</span> <span class="k">else</span> <span class="n">underscore</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.without"><a class="viewcode-back" href="../index.html#underscore.underscore.without">[docs]</a>	<span class="k">def</span> <span class="nf">without</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a copy of the **array** with all instances in  ***values** removed.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.without([1, 2, 1, 0, 3, 1, 4], 0, 1)</span>
<span class="sd">            [2, 3, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a list&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.union"><a class="viewcode-back" href="../index.html#underscore.underscore.union">[docs]</a>	<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the union of the passed-in **arrays**: a list of unique items, in order,</span>
<span class="sd">		that are present in one or more of the **arrays**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.union([1, 2, 3], [101, 2, 1, 10], [2, 1])</span>
<span class="sd">            [1, 2, 3, 101, 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[]</span>

		<span class="n">check</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
		<span class="k">if</span> <span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;all arguments must be arrays&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">retval</span><span class="p">:</span>
							<span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.intersection"><a class="viewcode-back" href="../index.html#underscore.underscore.intersection">[docs]</a>	<span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of values that are the intersection of all the **arrays**.</span>
<span class="sd">		Each value in the result is present in each of the **arrays**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1])</span>
<span class="sd">            [1, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[]</span>

		<span class="k">if</span> <span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;all arguments must be arrays&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">curr</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">curr</span><span class="p">:</span>
					<span class="n">to_be_added</span> <span class="o">=</span> <span class="bp">True</span>
					<span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
						<span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Z</span><span class="p">:</span>
							<span class="n">to_be_added</span> <span class="o">=</span> <span class="bp">False</span>
							<span class="k">break</span>
					<span class="k">if</span> <span class="n">to_be_added</span><span class="p">:</span> <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">retval</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.difference"><a class="viewcode-back" href="../index.html#underscore.underscore.difference">[docs]</a>	<span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">*</span><span class="n">others</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :py:meth:`without`, but returns the values from **array** that are not present in the other arrays.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.difference([1, 2, 3, 4, 5], [5, 2, 10])</span>
<span class="sd">            [1, 3, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be an array&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">]</span>

		<span class="k">if</span> <span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">others</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;all arguments must be arrays&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">:</span>
				<span class="n">to_be_added</span> <span class="o">=</span> <span class="bp">True</span>
				<span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
						<span class="n">to_be_added</span> <span class="o">=</span> <span class="bp">False</span>
						<span class="k">break</span>
				<span class="k">if</span> <span class="n">to_be_added</span><span class="p">:</span> <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span>

	<span class="c1"># noinspection PyShadowingNames,PyShadowingNames</span></div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.uniq"><a class="viewcode-back" href="../index.html#underscore.underscore.uniq">[docs]</a>	<span class="k">def</span> <span class="nf">uniq</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`uniq`, :py:meth:`unique`</span>

<span class="sd">        Returns a duplicate-free version of the **array**, based on the **in** operator of Python&#39;s list. If you want to compute unique items after a transformation, pass an **iteratee** function (the retained element in the array will be the first one found).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.uniq([1, 2, 1, 3, 1, 4, 2])</span>
<span class="sd">            [1, 2, 3, 4]</span>
<span class="sd">            &gt;&gt;&gt; _.uniq([1, 1, 1, 2, 3, 4, 4, 5], isSorted = True)</span>
<span class="sd">            [1, 2, 3, 4, 5]</span>
<span class="sd">            &gt;&gt;&gt; _.uniq([1.5, 1.7, 2.0, 2.5, 2.5, 3.0, 4.0], iteratee = math.floor)</span>
<span class="sd">            [1.5, 2.0, 3.0, 4.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be an array&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">to_compare</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
			<span class="n">retval</span>      <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="n">comparisons</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_compare</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
			<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
				<span class="n">y</span> <span class="o">=</span> <span class="n">to_compare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comparisons</span><span class="p">:</span>
					<span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
					<span class="n">comparisons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">retval</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.zip"><a class="viewcode-back" href="../index.html#underscore.underscore.zip">[docs]</a>	<span class="k">def</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges together the values of each of the **arrays** with the values at the</span>
<span class="sd">		corresponding position. Useful when you have separate data sources that</span>
<span class="sd">		are coordinated through matching array indexes. If the arguments are tuples,</span>
<span class="sd">		a tuple is returned in each position, otherwise an array.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.zip([&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;], [30, 40, 50], [True, False, False])</span>
<span class="sd">            [[&#39;moe&#39;, 30, True], [&#39;larry&#39;, 40, False], [&#39;curly&#39;, 50, False]]</span>
<span class="sd">            &gt;&gt;&gt; _.zip((&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;), (30, 40, 50), (True, False, False))</span>
<span class="sd">            [(&#39;moe&#39;, 30, True), (&#39;larry&#39;, 40, False), (&#39;curly&#39;, 50, False)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="bp">False</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;all arguments must be arrays&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
				<span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">zipped</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">zipped</span><span class="p">]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.object"><a class="viewcode-back" href="../index.html#underscore.underscore.object">[docs]</a>	<span class="k">def</span> <span class="nf">object</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts arrays into a dictionary and return it. Pass either a single list of ``[key, value]`` (or ``(key, value)``) pairs, or a list of keys, and a list of values. If duplicate keys exist, the last value wins.</span>

<span class="sd">		The first option is an alias to a possible ``dict`` constructor in Python.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.object([[&#39;moe&#39;, 30], [&#39;larry&#39;, 40], [&#39;curly&#39;, 50]])</span>
<span class="sd">            {&#39;larry&#39;: 40, &#39;curly&#39;: 50, &#39;moe&#39;: 30}</span>
<span class="sd">            &gt;&gt;&gt; _.object([(&#39;moe&#39;, 30), (&#39;larry&#39;, 40), (&#39;curly&#39;, 50)])</span>
<span class="sd">            {&#39;larry&#39;: 40, &#39;curly&#39;: 50, &#39;moe&#39;: 30}</span>
<span class="sd">            &gt;&gt;&gt; _.object([&#39;moe&#39;, &#39;larry&#39;, &#39;curly&#39;], [30, 40, 50])</span>
<span class="sd">            {&#39;larry&#39;: 40, &#39;curly&#39;: 50, &#39;moe&#39;: 30}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;all arguments must be arrays&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)))}</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.indexOf"><a class="viewcode-back" href="../index.html#underscore.underscore.indexOf">[docs]</a>	<span class="k">def</span> <span class="nf">indexOf</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index at which **value** can be found in the **array**, or -1 if value is not present in the **array**. The values of **startIndex** and **endIndex** may be used to refer to an interval where the search should be made.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.indexOf([1, 2, 3, 1, 2, 3, 4, 2, 5], 2)</span>
<span class="sd">            1</span>
<span class="sd">            &gt;&gt;&gt; _.indexOf([1, 2, 3, 1, 2, 3, 4, 2, 5], 2, 3, 6)</span>
<span class="sd">            4</span>
<span class="sd">            _.indexOf([1, 2, 3, 1, 2, 3, 4, 2, 5], 10)</span>
<span class="sd">            -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="c1"># I could have relied on findIndex, but this is way simpler. Actually, I could have</span>
		<span class="c1"># also used the built-in facility, but the lastIndexOf cannot be done that way, so</span>
		<span class="c1"># I kept this for the sake of symmetry, but also to use bisect for large arrays</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be a list&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">endIndex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">endIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.lastIndexOf"><a class="viewcode-back" href="../index.html#underscore.underscore.lastIndexOf">[docs]</a>	<span class="k">def</span> <span class="nf">lastIndexOf</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of the last occurrence of value in the **array**, or -1 if value is not present. The values of **startIndex** and **endIndex** may be used to refer to an interval where the search should be made.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.lastIndexOf([1, 2, 3, 1, 2, 3, 4, 2, 5], 2)</span>
<span class="sd">            7</span>
<span class="sd">            &gt;&gt;&gt; _.indexOf([1, 2, 3, 1, 2, 3, 4, 2, 5], 2, 3, 6)</span>
<span class="sd">            4</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be a list&quot;</span><span class="p">)</span>
		<span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="k">if</span> <span class="n">endIndex</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">endIndex</span>
		<span class="n">end</span>   <span class="o">=</span> <span class="n">startIndex</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">i</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.sortedIndex"><a class="viewcode-back" href="../index.html#underscore.underscore.sortedIndex">[docs]</a>	<span class="k">def</span> <span class="nf">sortedIndex</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the index at which the **value** should be inserted into the **array** in order to maintain the list&#39;s sorted order. If an **iteratee** function is provided, it will be used to compute the sort ranking of each value, including the value you pass. The **iteratee** may also be the string, providing the name of the key to sort by.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.sortedIndex([10, 20, 30, 40, 50], 35)</span>
<span class="sd">            3</span>
<span class="sd">            &gt;&gt;&gt; _.sortedIndex([10, 20, 30, 40, 50], 55)</span>
<span class="sd">            5</span>
<span class="sd">            &gt;&gt;&gt; stooges2 = [{&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 40}, {&#39;name&#39;: &#39;curly&#39;, &#39;age&#39;: 60}]</span>
<span class="sd">            &gt;&gt;&gt; _.sortedIndex(stooges2, {&#39;name&#39;: &#39;larry&#39;, &#39;age&#39;: 50}, &#39;age&#39;)</span>
<span class="sd">            1</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="c1"># The version with a real iteratee is inefficient for larger arrays.</span>
		<span class="c1"># Ideally, the bisect module should be rewritten to use the iteratee directly. T.B.D.</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be a list&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">array</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">value</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span><span class="p">]</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.findIndex"><a class="viewcode-back" href="../index.html#underscore.underscore.findIndex">[docs]</a>	<span class="k">def</span> <span class="nf">findIndex</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">None</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :py:meth:`indexOf`, returns the first index where the predicate truth test passes; otherwise returns -1. The values of **startIndex** and **endIndex** may be used to refer to an interval where the search should be made.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; def isPrime(n):</span>
<span class="sd">            ...     (— definition of the function)</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; _.findIndex([4, 6, 8, 12], isPrime)</span>
<span class="sd">            -1</span>
<span class="sd">            &gt;&gt;&gt; _.findIndex([4, 6, 7, 12], isPrime)</span>
<span class="sd">            2</span>
<span class="sd">            &gt;&gt;&gt; _.findIndex([4, 6, 3, 12, 14, 16], isPrime, startIndex=3)</span>
<span class="sd">            -1</span>
<span class="sd">            &gt;&gt;&gt; _.findIndex([4, 6, 3, 12, 14, 16], isPrime, startIndex=1, endIndex=5)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be a list&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">endIndex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">endIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">endIndex</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
				<span class="k">return</span> <span class="n">i</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.findLastIndex"><a class="viewcode-back" href="../index.html#underscore.underscore.findLastIndex">[docs]</a>	<span class="k">def</span> <span class="nf">findLastIndex</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">startIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like :py:meth:`findIndex` but iterates the array in reverse, returning the index closest to the end where the predicate truth test passes. The values of **startIndex** and **endIndex** may be used to refer to an interval where the search should be made.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.findLastIndex([4, 6, 5, 7, 12],isPrime)</span>
<span class="sd">            3</span>
<span class="sd">            &gt;&gt;&gt; _.findLastIndex([2, 6, 7, 12, 13, 16], isPrime, startIndex = 1, endIndex = 3)</span>
<span class="sd">            2</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be a list&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">endIndex</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">endIndex</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">endIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">startIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
				<span class="k">return</span> <span class="n">i</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.range"><a class="viewcode-back" href="../index.html#underscore.underscore.range">[docs]</a>	<span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function to create flexibly-numbered lists of integers, handy for each and map loops. The combination of the arguments can be:</span>

<span class="sd">        * **end**: return a list of integers between 0 and **end**, with **end** non inclusive</span>
<span class="sd">        * **start**, **end**: like before but starting at **start** instead of 0</span>
<span class="sd">        * **start**, **end**, **step**: like before, but stepping with **step** instead of 1. **step** can also be negative</span>

<span class="sd">        This is just an alias to Python2&#39;s built-in **range** function. In Python3, the result of the same built-in is turned into a list before return.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.range(10)</span>
<span class="sd">            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">            &gt;&gt;&gt; _.range(3, 10)</span>
<span class="sd">            [3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">            &gt;&gt;&gt; _.range(3, 10, 2)</span>
<span class="sd">            [3, 5, 7, 9]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span> <span class="k">if</span> <span class="n">PY3</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

	<span class="c1">###############################################################################</span>
	<span class="c1">#                             Function Functions                              #</span>
	<span class="c1">###############################################################################</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.partial"><a class="viewcode-back" href="../index.html#underscore.underscore.partial">[docs]</a>	<span class="k">def</span> <span class="nf">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a partially bounded version of the function **func** by fixing any number of its arguments and keywords. You may pass ``None`` in your list of arguments to specify an argument that should not be pre-filled, but left open to supply at call-time.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; substract = lambda a, b: b - a</span>
<span class="sd">            &gt;&gt;&gt; sub5 = _.partial(substract, 5)</span>
<span class="sd">            &gt;&gt;&gt; sub5(20)</span>
<span class="sd">            15</span>
<span class="sd">            &gt;&gt;&gt; subFrom20 = _.partial(substract, None, 20)</span>
<span class="sd">            &gt;&gt;&gt; subFrom20(5)</span>
<span class="sd">            15</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="p">()</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
					<span class="n">retval</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
					<span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">retval</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
			<span class="k">return</span> <span class="n">retval</span> <span class="o">+</span> <span class="n">b</span>

		<span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="o">*</span><span class="n">fargs</span><span class="p">,</span> <span class="o">**</span><span class="n">fkeywords</span><span class="p">):</span>
			<span class="n">newkeywords</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
			<span class="n">newkeywords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fkeywords</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">combine</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fargs</span><span class="p">)),</span> <span class="o">**</span><span class="n">newkeywords</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">newfunc</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.once"><a class="viewcode-back" href="../index.html#underscore.underscore.once">[docs]</a>	<span class="k">def</span> <span class="nf">once</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a version of **func**, as a callable object, that can only be called one time. Repeated calls to the modified function will have no effect, returning the value from the original call.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; initialize = _.once(createApplication)</span>
<span class="sd">            &gt;&gt;&gt; initialize()</span>
<span class="sd">            created</span>
<span class="sd">            &gt;&gt;&gt; initialize()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">underscore</span><span class="o">.</span><span class="n">before</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.after"><a class="viewcode-back" href="../index.html#underscore.underscore.after">[docs]</a>	<span class="k">def</span> <span class="nf">after</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a version of **func**, as a callable object, that will only be run after first being called **count** times.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; delayInit = _.after(2, createApplication)</span>
<span class="sd">            &gt;&gt;&gt; delayInit()</span>
<span class="sd">            &gt;&gt;&gt; delayInit()</span>
<span class="sd">            &gt;&gt;&gt; delayInit()</span>
<span class="sd">            created</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">class</span> <span class="nc">_after</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
			<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">after_count</span><span class="p">,</span> <span class="n">after_func</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">count</span>  <span class="o">=</span> <span class="n">after_count</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">func</span>   <span class="o">=</span> <span class="n">after_func</span>

			<span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">_after</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.before"><a class="viewcode-back" href="../index.html#underscore.underscore.before">[docs]</a>	<span class="k">def</span> <span class="nf">before</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a version of **func**, as a callable object, that can be called no more than **count** times. The result of the last function call is memorized and returned when count has been reached.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; createOnly3 = _.before(3, createApplication)</span>
<span class="sd">            &gt;&gt;&gt; createOnly3()</span>
<span class="sd">            created</span>
<span class="sd">            &gt;&gt;&gt; createOnly3()</span>
<span class="sd">            created</span>
<span class="sd">            &gt;&gt;&gt; createOnly3()</span>
<span class="sd">            created</span>
<span class="sd">            &gt;&gt;&gt; createOnly3()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">class</span> <span class="nc">_before</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
			<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_count</span><span class="p">,</span> <span class="n">before_func</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">count</span>  <span class="o">=</span> <span class="n">before_count</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">retval</span> <span class="o">=</span> <span class="bp">None</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">func</span>   <span class="o">=</span> <span class="n">before_func</span>

			<span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">retval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">retval</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">retval</span>
		<span class="k">return</span> <span class="n">_before</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.wrap"><a class="viewcode-back" href="../index.html#underscore.underscore.wrap">[docs]</a>	<span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps the first **function** inside of the **wrapper** function, passing it as the first argument. This allows the wrapper to execute code before and after the function runs, adjust the arguments, or execute it conditionally. The generated functions can have arguments and keywords, which will be forwarded to the **wrapper**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; func = lambda x: &quot;Hello: &quot; +x</span>
<span class="sd">            &gt;&gt;&gt; def wrap(f, *args, **keywords):</span>
<span class="sd">            ...     print(args)</span>
<span class="sd">            ...     print(keywords)</span>
<span class="sd">            ...     print(&quot;before, &quot; + f(&quot;name&quot;) + &quot;, after&quot;)</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; wrapper = _.wrap(func, wrap)</span>
<span class="sd">            &gt;&gt;&gt; wrapper(1, 2, 3, a=1)</span>
<span class="sd">            (1, 2, 3)</span>
<span class="sd">            {&#39;a&#39;: 1}</span>
<span class="sd">            before, Hello: name, after</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ff</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.negate"><a class="viewcode-back" href="../index.html#underscore.underscore.negate">[docs]</a>	<span class="k">def</span> <span class="nf">negate</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a new negated version of the **predicate** function (invoked with the arguments).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; test = lambda x, y: x and y</span>
<span class="sd">            &gt;&gt;&gt; _.negate(test,False,True)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; _.negate(test,True,True)</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="ow">not</span> <span class="n">predicate</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.compose"><a class="viewcode-back" href="../index.html#underscore.underscore.compose">[docs]</a>	<span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="o">*</span><span class="n">functions</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the composition of a list of **functions**, where each function consumes the return value of the function that follows. In math terms, composing the functions ``f()``, ``g()``, and ``h()`` produces ``f(g(h()))``. The composition function can be invoked with arguments, which will be used for the arguments of the innermost function (``h()`` in this example).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; greet    = lambda name: &quot;hi: &quot; + name</span>
<span class="sd">            &gt;&gt;&gt; exclaim  = lambda statement: statement.upper() + &quot;!&quot;</span>
<span class="sd">            &gt;&gt;&gt; welcome  = _.compose(greet, exclaim)</span>
<span class="sd">            &gt;&gt;&gt; welcome(&#39;moe&#39;)</span>
<span class="sd">            &#39;hi: MOE!&#39;</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
			<span class="n">nextarg</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
				<span class="n">nextarg</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">nextarg</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">nextarg</span>
		<span class="k">return</span> <span class="n">ff</span>

	<span class="c1">###############################################################################</span>
	<span class="c1">#                       Object (dictionary) Functions                         #</span>
	<span class="c1">###############################################################################</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.keys"><a class="viewcode-back" href="../index.html#underscore.underscore.keys">[docs]</a>	<span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Retrieve all the names of the **object**&#39;s own enumerable properties. Alias of the built-in Python method, but in case of Python3, it returns a list and not an iterator.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.keys({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">            [&#39;three&#39;, &#39;two&#39;, &#39;one&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">PY3</span> <span class="k">else</span> <span class="nb">object</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.values"><a class="viewcode-back" href="../index.html#underscore.underscore.values">[docs]</a>	<span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Retrieve all the names of the object&#39;s own enumerable properties. Alias of the built-in Python method.</span>

<span class="sd">        In Python3 this returns an iterator; in Python2 a list.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.values({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">            [3,2,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="n">PY3</span> <span class="k">else</span> <span class="nb">object</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.mapObject"><a class="viewcode-back" href="../index.html#underscore.underscore.mapObject">[docs]</a>	<span class="k">def</span> <span class="nf">mapObject</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">iteratee</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">            :py:meth:`mapObject`, :py:meth:`collectObject`</span>

<span class="sd">		Like :py:meth:`map`, but for objects (a.k.a. dictionaries). Transform the value of each property in turn. The **iteratee** is passed three arguments: the ``index`` (or ``key``) of the iteration, the ``value``, and finally a reference to the entire list. If **iteratee** is not set or is ``None``, a copy of **obj** is returned.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.mapObject({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">            {&#39;one&#39;: 1, &#39;three&#39;: 3, &#39;two&#39;: 2}</span>
<span class="sd">            &gt;&gt;&gt; _.mapObject({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}, lambda key, val, obj: 3*val)</span>
<span class="sd">            {&#39;one&#39;: 3, &#39;three&#39;: 9, &#39;two&#39;: 6}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">iteratee</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">underscore</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">transform</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">key</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec3</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">obj</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">}</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.pairs"><a class="viewcode-back" href="../index.html#underscore.underscore.pairs">[docs]</a>	<span class="k">def</span> <span class="nf">pairs</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">tupl</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Convert an **obj** into a list of ``[key, value]`` pairs. If the value of **tuple** is set to ``True``, an array of tuples is returned, instead of an array of (binary) arrays.</span>

<span class="sd">        In Python3 this returns an iterator; in Python2 a list.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.pairs({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">            [[&#39;three&#39;, 3], [&#39;two&#39;, 2], [&#39;one&#39;, 1]]</span>
<span class="sd">            &gt;&gt;&gt; _.pairs({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}, tupl = True)</span>
<span class="sd">            [(&#39;three&#39;, 3), (&#39;two&#39;, 2), (&#39;one&#39;, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">tupl</span><span class="p">:</span>
				<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">PY3</span> <span class="k">else</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">return</span> <span class="p">[[</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.invert"><a class="viewcode-back" href="../index.html#underscore.underscore.invert">[docs]</a>	<span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a copy of **obj** where the keys have become the values and the values the keys. For this to work, all of your object&#39;s values should be unique and string serializable.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.invert({&quot;Moe&quot;: &quot;Moses&quot;, &quot;Larry&quot;: &quot;Louis&quot;, &quot;Curly&quot;: &quot;Jerome&quot;})</span>
<span class="sd">            {&#39;Louis&#39;: &#39;Larry&#39;, &#39;Moses&#39;: &#39;Moe&#39;, &#39;Jerome&#39;: &#39;Curly&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.findKey"><a class="viewcode-back" href="../index.html#underscore.underscore.findKey">[docs]</a>	<span class="k">def</span> <span class="nf">findKey</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the a key where the predicate truth test passes; if none found, returns ``None``.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.findKey({&quot;Moe&quot;: &quot;Moses&quot;, &quot;Larry&quot;: &quot;Louis&quot;, &quot;Curly&quot;: &quot;Jerome&quot;}, lambda val: val == &quot;Jerome&quot;)</span>
<span class="sd">            Curly</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">check</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">check</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
					<span class="k">return</span> <span class="n">key</span>
			<span class="k">return</span> <span class="bp">None</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.extend"><a class="viewcode-back" href="../index.html#underscore.underscore.extend">[docs]</a>	<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Copy all of the properties in the source objects of **sources** over to the **destination** object. It&#39;s in-order, so the last source will override properties of the same name in previous arguments.  Returns **destination** (for possible chaining).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.extend({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: &#39;40&#39;}, {&#39;age&#39;: 50}, {&#39;age&#39;: 60, &#39;gender&#39;: &#39;male&#39;})</span>
<span class="sd">            {&#39;gender&#39;: &#39;male&#39;, &#39;age&#39;: 60, &#39;name&#39;: &#39;moe&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be dictionaries&quot;</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
				<span class="n">destination</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">destination</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.extendOwn"><a class="viewcode-back" href="../index.html#underscore.underscore.extendOwn">[docs]</a>	<span class="k">def</span> <span class="nf">extendOwn</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="o">*</span><span class="n">sources</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Like **extend**, but only copies *own* properties over to the destination object. Return **destination** (for possible chaining).</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.extendOwn({&#39;name&#39;: &#39;moe&#39;, age: &#39;40&#39;}, {&#39;age&#39;: 50}, {&#39;age&#39;: 60, &#39;gender&#39;: &#39;male&#39;})</span>
<span class="sd">            {&#39;age&#39;: 60, &#39;name&#39;: &#39;moe&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be dictionaries&quot;</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">destination</span><span class="p">:</span>
					<span class="n">destination</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">destination</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.pick"><a class="viewcode-back" href="../index.html#underscore.underscore.pick">[docs]</a>	<span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of **obj**, filtered to only have values for the whitelisted **keys** (or array of valid keys). Alternatively, accepts a predicate indicating which keys to pick.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.pick({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 50, &#39;userid&#39;: &#39;moe1&#39;}, &#39;name&#39;, &#39;age&#39;)</span>
<span class="sd">            {&#39;age&#39;: 50, &#39;name&#39;: &#39;moe&#39;}</span>
<span class="sd">            &gt;&gt;&gt; a = [&#39;name&#39;, &#39;age&#39;]</span>
<span class="sd">            &gt;&gt;&gt; _.pick({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 50, &#39;userid&#39;: &#39;moe1&#39;}, *a)</span>
<span class="sd">            {&#39;age&#39;: 50, &#39;name&#39;: &#39;moe&#39;}</span>
<span class="sd">            &gt;&gt;&gt; _.pick({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 50, &#39;userid&#39;: &#39;moe1&#39;}, lambda val, *args: _.isNumber(val))</span>
<span class="sd">            {&#39;age&#39;: 50}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{}</span>
		<span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span> <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">)}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.omit"><a class="viewcode-back" href="../index.html#underscore.underscore.omit">[docs]</a>	<span class="k">def</span> <span class="nf">omit</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of **obj**, filtered to omit values for the blacklisted **keys** (or array of valid keys). Alternatively accepts a predicate indicating which keys to pick.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.omit({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 50, &#39;userid&#39;: &#39;moe1&#39;}, &#39;name&#39;, &#39;age&#39;)</span>
<span class="sd">            {&#39;userid&#39;: &#39;moe1&#39;}</span>
<span class="sd">            &gt;&gt;&gt; a = [&#39;name&#39;, &#39;age&#39;]</span>
<span class="sd">            &gt;&gt;&gt; _.omit({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 50, &#39;userid&#39;: &#39;moe1&#39;}, *a)</span>
<span class="sd">            {&#39;userid&#39;: &#39;moe1&#39;}</span>
<span class="sd">            &gt;&gt;&gt; _.omit({&#39;name&#39;: &#39;moe&#39;, &#39;age&#39;: 50, &#39;userid&#39;: &#39;moe1&#39;}, lambda val, *args: _.isNumber(val))</span>
<span class="sd">            {&#39;userid&#39;: &#39;moe1&#39;, &#39;name&#39;: &#39;moe&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">{}</span>
		<span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">)}</span>
		<span class="k">else</span> <span class="p">:</span>
			<span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.defaults"><a class="viewcode-back" href="../index.html#underscore.underscore.defaults">[docs]</a>	<span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">defaults</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Fill in undefined properties in **obj** with the first value present in the following list of **defaults** objects. Return **obj** (for possible chaining)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; iceCream = {&#39;flavor&#39;: &quot;chocolate&quot;}</span>
<span class="sd">            &gt;&gt;&gt; _.defaults(iceCream, {&#39;flavor&#39;: &quot;vanilla&quot;, &#39;sprinkles&#39;: &quot;lots&quot;})</span>
<span class="sd">            {&#39;flavor&#39;: &#39;chocolate&#39;, &#39;sprinkles&#39;: &#39;lots&#39;}</span>
<span class="sd">            &gt;&gt;&gt; myDefaults = [{&#39;flavor&#39;:&#39;vanilla&#39;, &#39;sprinkles&#39;:&#39;lots&#39;}, {&#39;toGo&#39;: True}]</span>
<span class="sd">            &gt;&gt;&gt; _.defaults(iceCream, *myDefaults)</span>
<span class="sd">            {&#39;flavor&#39;: &#39;chocolate&#39;, &#39;sprinkles&#39;: &#39;lots&#39;, &#39;toGo&#39; : True}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">False</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">]):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be dictionaries&quot;</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">default</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span> <span class="p">:</span>
					<span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">obj</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.clone"><a class="viewcode-back" href="../index.html#underscore.underscore.clone">[docs]</a>	<span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">deep</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a clone of the provided plain **obj**. If ``deep`` is False, then any nested objects or arrays will be copied by reference, not duplicated; otherwise each constituent arrays or dictionaries will also be cloned (recursively).</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="kn">import</span> <span class="nn">copy</span>
		<span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.has"><a class="viewcode-back" href="../index.html#underscore.underscore.has">[docs]</a>	<span class="k">def</span> <span class="nf">has</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if the object contain the given key, ``False`` otherwise. Alias to built in dictionary method&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.property"><a class="viewcode-back" href="../index.html#underscore.underscore.property">[docs]</a>	<span class="k">def</span> <span class="nf">property</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">        :py:meth:`property`, :py:meth:`attribute`</span>

<span class="sd">		Returns a function that will itself return the **key** property of any passed-in object.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; getName = _.property(&#39;name&#39;)</span>
<span class="sd">            &gt;&gt;&gt; getName(stooges[3])</span>
<span class="sd">            joe</span>
<span class="sd">            &gt;&gt;&gt; getName(stooges0[0])</span>
<span class="sd">            moe</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.propertyOf"><a class="viewcode-back" href="../index.html#underscore.underscore.propertyOf">[docs]</a>	<span class="k">def</span> <span class="nf">propertyOf</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Aliases**:</span>
<span class="sd">           :py:meth:`propertyOf`, :py:meth:`attributeOf`</span>

<span class="sd">		Inverse of :py:meth:`property`. Takes an **obj** and returns a function which will return the value of a provided property. In effect, the functional equivalent of ``obj[key]`` where ``obj`` is fixed.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; getValue = _.propertyOf(stooges[3])</span>
<span class="sd">            &gt;&gt;&gt; getValue(&#39;name&#39;)</span>
<span class="sd">            joe</span>
<span class="sd">            &gt;&gt;&gt; getValue(&#39;age&#39;)</span>
<span class="sd">            60</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="k">lambda</span> <span class="n">key</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.matcher"><a class="viewcode-back" href="../index.html#underscore.underscore.matcher">[docs]</a>	<span class="k">def</span> <span class="nf">matcher</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a predicate function that will tell if a passed object contains all of the key/value properties present in **attrs**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; checkAge = _.matcher({&#39;age&#39;: 60})</span>
<span class="sd">            &gt;&gt;&gt; checkAge(stooges[0])</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; CheckAge(stooges[2])</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be a dictionary&quot;</span><span class="p">)</span>

		<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">obj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
					<span class="k">return</span> <span class="bp">False</span>
			<span class="k">return</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="n">func</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isMatch"><a class="viewcode-back" href="../index.html#underscore.underscore.isMatch">[docs]</a>	<span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns ``True`` if the keys and values in **properties** are contained in **obj**, ``False`` otherwise.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.isMatch(stooge[0], {&#39;age&#39;: 40})</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; _.isMatch(stooge[3], {&#39;age&#39;: 40})</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments must be dictionaries&quot;</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">underscore</span><span class="o">.</span><span class="n">matcher</span><span class="p">(</span><span class="n">properties</span><span class="p">)(</span><span class="n">obj</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isEqual"><a class="viewcode-back" href="../index.html#underscore.underscore.isEqual">[docs]</a>	<span class="k">def</span> <span class="nf">isEqual</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Performs an optimized deep comparison between **obj** and **other**, returns ``True`` if they are equal, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">obj</span> <span class="o">==</span> <span class="n">other</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isEmpty"><a class="viewcode-back" href="../index.html#underscore.underscore.isEmpty">[docs]</a>	<span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns ``True`` if an enumerable object contains no values (no enumerable own-properties), ``False`` otherwise. For strings and array-like objects the function checks if the length property is 0.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isArray"><a class="viewcode-back" href="../index.html#underscore.underscore.isArray">[docs]</a>	<span class="k">def</span> <span class="nf">isArray</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is an Array (i.e., List), ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isTuple"><a class="viewcode-back" href="../index.html#underscore.underscore.isTuple">[docs]</a>	<span class="k">def</span> <span class="nf">isTuple</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is an Tuple, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isObject"><a class="viewcode-back" href="../index.html#underscore.underscore.isObject">[docs]</a>	<span class="k">def</span> <span class="nf">isObject</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is an “Object” (i.e., Dictionary), ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">isintance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isFunction"><a class="viewcode-back" href="../index.html#underscore.underscore.isFunction">[docs]</a>	<span class="k">def</span> <span class="nf">isFunction</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is a function or a method, ``False`` otherwise.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.isFunction(isPrime)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; _.isFunction(lambda x: x+1)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; _.isFunction(1)</span>
<span class="sd">            False</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">LambdaType</span><span class="p">,</span> <span class="n">FunctionType</span><span class="p">,</span> <span class="n">MethodType</span><span class="p">))</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isCallable"><a class="viewcode-back" href="../index.html#underscore.underscore.isCallable">[docs]</a>	<span class="k">def</span> <span class="nf">isCallable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is callable, ``False`` otherwise. Note that this is a more general form of test than :py:meth:`isFunction`&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isString"><a class="viewcode-back" href="../index.html#underscore.underscore.isString">[docs]</a>	<span class="k">def</span> <span class="nf">isString</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is a string, ``False`` otherwise. For Python2 this checks against a string or a unicode. In (Python3 there is no such distinction.)&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isNumber"><a class="viewcode-back" href="../index.html#underscore.underscore.isNumber">[docs]</a>	<span class="k">def</span> <span class="nf">isNumber</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is a number (float or integer), ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isFinite"><a class="viewcode-back" href="../index.html#underscore.underscore.isFinite">[docs]</a>	<span class="k">def</span> <span class="nf">isFinite</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is number with a finite value, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isNaN"><a class="viewcode-back" href="../index.html#underscore.underscore.isNaN">[docs]</a>	<span class="k">def</span> <span class="nf">isNaN</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is a float with ``NaN`` as value, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isBoolean"><a class="viewcode-back" href="../index.html#underscore.underscore.isBoolean">[docs]</a>	<span class="k">def</span> <span class="nf">isBoolean</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is a Boolean, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isError"><a class="viewcode-back" href="../index.html#underscore.underscore.isError">[docs]</a>	<span class="k">def</span> <span class="nf">isError</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is an Exception, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.isNone"><a class="viewcode-back" href="../index.html#underscore.underscore.isNone">[docs]</a>	<span class="k">def</span> <span class="nf">isNone</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return ``True`` if **obj** is ``None``, ``False`` otherwise.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span>

	<span class="c1">###############################################################################</span>
	<span class="c1">#                              Utility Functions                              #</span>
	<span class="c1">###############################################################################</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.identity"><a class="viewcode-back" href="../index.html#underscore.underscore.identity">[docs]</a>	<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the same value that is used as the first argument (and ignore everything else). In math: ``f(x) = x``. This function looks useless, but can be used when debugging other underscore methods.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">x</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.constant"><a class="viewcode-back" href="../index.html#underscore.underscore.constant">[docs]</a>	<span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a function that always returns the same **value**.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; stooge = {&#39;name&#39;: &#39;moe&#39; }</span>
<span class="sd">            &gt;&gt;&gt; const = _.constant(stooge)</span>
<span class="sd">            &gt;&gt;&gt; const()</span>
<span class="sd">            {&#39;name&#39;: &#39;moe&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">value</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.noop"><a class="viewcode-back" href="../index.html#underscore.underscore.noop">[docs]</a>	<span class="k">def</span> <span class="nf">noop</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns ``None`` irrespective of the arguments passed to it. Useful as the default for optional callback arguments.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">None</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.times"><a class="viewcode-back" href="../index.html#underscore.underscore.times">[docs]</a>	<span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invokes the given **iteratee** function **n** times. Each invocation of **iteratee** is called with an index argument. Produces an array of the returned values.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; _.times(3, _.identity)</span>
<span class="sd">            [0, 1, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">underscore</span><span class="o">.</span><span class="n">_exec1</span><span class="p">(</span><span class="n">iteratee</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.random"><a class="viewcode-back" href="../index.html#underscore.underscore.random">[docs]</a>	<span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns a pseudo-random integer between **min** and **max**, inclusive. If you only pass one argument, it will return a number between 0 and that number. The pseudo-random generator should not be used for security purposes.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">max</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span><span class="nb">int</span><span class="p">))</span> <span class="p">:</span>
			<span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">)</span> <span class="k">if</span> <span class="nb">max</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments should be integeters&quot;</span><span class="p">)</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.uniqueId"><a class="viewcode-back" href="../index.html#underscore.underscore.uniqueId">[docs]</a>	<span class="k">def</span> <span class="nf">uniqueId</span><span class="p">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a globally-unique id as a string. If **prefix** is passed, the id will be appended to it. The method relies on the ``uuid.uuid1()`` library function, i.e., is based on the host ID and the current time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="kn">import</span> <span class="nn">uuid</span>
		<span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span> <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">())</span>
</div>
	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.now"><a class="viewcode-back" href="../index.html#underscore.underscore.now">[docs]</a>	<span class="k">def</span> <span class="nf">now</span><span class="p">():</span>
		<span class="sd">&quot;&quot;&quot;Returns an integer timestamp for the current time&quot;&quot;&quot;</span>
		<span class="kn">import</span> <span class="nn">time</span>
		<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

	<span class="c1">###############################################################################</span>
	<span class="c1">#                                    Chaining                                 #</span>
	<span class="c1">###############################################################################</span>

	<span class="c1"># Chaining is done by creating an instance of underscore, and catching all method requests</span></div>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">current_value</span> <span class="o">=</span> <span class="n">val</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">chaining_on</span>   <span class="o">=</span> <span class="bp">True</span>

	<span class="c1"># This method catches **all** attribute dereference attempts. This means that any access to the local variables</span>
	<span class="c1"># must be done through the superclass and through the special attributes. A bit convoluted, but does the job...</span>
	<span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
			<span class="c1"># noinspection PyCallByClass</span>
			<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
				<span class="c1">#</span>
				<span class="c1"># i.e.:</span>
				<span class="c1"># self.chaining_on = True</span>
				<span class="c1"># return self.current_value</span>
				<span class="c1">#</span>
				<span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;chaining_on&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
				<span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;current_value&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">func</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;tap&quot;</span><span class="p">:</span>
			<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
				<span class="c1">#</span>
				<span class="c1"># i.e.:</span>
				<span class="c1"># f(self.current_value)</span>
				<span class="c1"># return self</span>
				<span class="c1">#</span>
				<span class="n">f</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;current_value&#39;</span><span class="p">))</span>
				<span class="k">return</span> <span class="bp">self</span>
			<span class="k">return</span> <span class="n">func</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;__module__&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;__doc__&quot;</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">underscore</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;chaining_on&#39;</span><span class="p">):</span>
			<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
				<span class="c1">#</span>
				<span class="c1"># I.e. (approximately)</span>
				<span class="c1"># self.current_value = underscore.`name`(self.current_value,*args)</span>
				<span class="c1"># return self</span>
				<span class="c1">#</span>
				<span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;current_value&#39;</span><span class="p">,</span> <span class="n">underscore</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="vm">__func__</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;current_value&#39;</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
				<span class="k">return</span> <span class="bp">self</span>
			<span class="k">return</span> <span class="n">func</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Chained value already retrieved, no more chaining&quot;</span><span class="p">)</span>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="underscore.chain"><a class="viewcode-back" href="../index.html#underscore.underscore.chain">[docs]</a>	<span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a wrapper object for chaining; see the separate description on chaining. The returned object has, beyond the static underscore methods, the additional instance methods:</span>

<span class="sd">        **value()**</span>
<span class="sd">             Extract the value of the wrapper object. A call to value means that no more chaining is possible.</span>

<span class="sd">        **tap(func)**</span>
<span class="sd">            Execute the function **func** on the value of the wrapped object; the object itself is returned, and can be used for further chaining. This can be used to &#39;tap into&#39; the chain.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; _.chain(stooges).sortBy(&#39;age&#39;).map(lambda st, *args: &quot;%s is %s&quot; % (st[&#39;name&#39;], st[&#39;age&#39;])).first().value()</span>
<span class="sd">            moe is 40</span>
<span class="sd">            &gt;&gt;&gt; def pr(a):</span>
<span class="sd">            ...        print(&quot;intermediate: %s&quot; % a)</span>
<span class="sd">            ...</span>
<span class="sd">            &gt;&gt;&gt; _.chain([1, 2, 3, 200]).filter(lambda num, *args: num % 2 == 0).map(lambda x, *args: x*x).value()</span>
<span class="sd">            [4, 40000]</span>
<span class="sd">            &gt;&gt;&gt; _.chain([1, 2, 3, 200]).filter(lambda num, *args: num % 2 == 0).tap(pr).map(lambda x, *args: x*x).value()</span>
<span class="sd">            intermediate: [2, 200]</span>
<span class="sd">            [4, 40000]</span>
<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">underscore</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

	<span class="c1">###############################################################################</span>
	<span class="c1">#                                   Aliases                                   #</span>
	<span class="c1">###############################################################################</span>

	<span class="c1"># Aliases to some of the core method names</span></div>
	<span class="n">forEach</span>       <span class="o">=</span> <span class="n">each</span>
	<span class="n">collect</span>       <span class="o">=</span> <span class="nb">map</span>
	<span class="n">collectObject</span> <span class="o">=</span> <span class="n">mapObject</span>
	<span class="n">inject</span>        <span class="o">=</span> <span class="nb">reduce</span>
	<span class="n">detect</span>        <span class="o">=</span> <span class="n">find</span>
	<span class="n">select</span>        <span class="o">=</span> <span class="nb">filter</span>
	<span class="nb">any</span>           <span class="o">=</span> <span class="n">some</span>
	<span class="n">include</span>       <span class="o">=</span> <span class="n">contains</span>
	<span class="n">unique</span>        <span class="o">=</span> <span class="n">uniq</span>
	<span class="n">attribute</span>     <span class="o">=</span> <span class="nb">property</span>
	<span class="n">attributeOf</span>   <span class="o">=</span> <span class="n">propertyOf</span>
</div>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
	<span class="k">pass</span>
</pre></div>

      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright Copyright (c) 2017 W3C® (MIT, ERCIM, Keio, Beihang).
      Last updated on 16 Jan, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>